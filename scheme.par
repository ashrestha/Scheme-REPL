[*
var sexprCount = 0;
var result = null;
var NIL = {type:'NULL'};
var create_list = function (x) { return {type:'LIST', val:[x]}; }
var array_append = function (x, y) { return [x,y]; }
var list = function (x, y) { return cons(x, cons(y, NIL)); };
var quote = function (x) { return list(intern("QUOTE", x)); };
var backquote = function (x) {return list(intern("BACKQUOTE", x)); };
var comma = function (x)  {return list(intern("COMMA", x)); };
var at = function (x)  {return list(intern("AT", x)); };
var append_improper_tail = function (list, x) { return FIXME; };
var cons = function (x,y) {return {type:'CONS', val:[x,y]}; };
var intern = function (x) {return {type:'SYMBOL', val:x}; };
var dump = function (x) { print(JSON.stringify(x)); };
*]

/~ Tokens Definitions for Scheme Syntax ~/

/~ Tokens to be ignored (e.g. whitespace, comments) ~/
! ' |\t|\r\n|\n|;[^\n]*\n' 
;

/~ Token pattern matching rules ~/
  '\)'    RPAREN
  '\('    LPAREN
  '\.'    DOT
  '[0-9]+|[0-9]+\.[0-9]*|[0-9]*\.[0-9]+'    NUMBER   [* %match = parseFloat( %match ); *]
  '[^\(\)0-9\.\'\`\,\@"].*'                 SYMBOL   /~ symbols cannot begin with digits, parens, quotes, dots, etc. ~/
  '\"[^"]*\"'                               STRING   [* %match = %match.substr( 1, %match.length - 2 ); *]
  ;

##


readonce:   sexpr                                    [* result = %1; *]
            ;

sexpr:      atom                                      
            | list                                   [* %% = %1; *]
            ;

list:       LPAREN RPAREN	                         [* %% = NIL; *]
	        | LPAREN members RPAREN                  [* %% = create_list(%2) *]
	        | LPAREN members DOT sexpr RPAREN        [* %% = append_improper_tail(%2, %4); *]
            ;

members:    members sexpr                            [* %% = array_append(%1, %2); *]
            | sexpr                                  [* %% = %1; *]
            ;

atom:       NUMBER                                   [* %% = {type:'NUMBER', val:%1}; *]
            | SYMBOL                                 [* %% = intern(%1); *]
            | STRING                                 [* %% = {type:'STRING', val:%1}; *]
            ;
            


[*
var error_offsets = new Array();
var error_lookaheads = new Array();
var error_count = 0;

/* Switching one of these variables on will enable debug facilities
        of the various parser drivers */
//##PREFIX##_dbg_withtrace = true;
//##PREFIX##_dbg_withparsetree = true;
//##PREFIX##_dbg_withstepbystep = true;

console.log("Welcome to the Scheme REPL by Travis Hoover\n");

process.stdin.resume();
process.stdin.setEncoding('utf8'); 
process.stdout.write("> ");

process.stdin.on('data', function (text) {

  if( text.trim() != "" ) {
    
    // Send text to scheme lex
    if( ( error_count = __NODEJS_parse( text.trim(), error_offsets, error_lookaheads ) ) > 0 ) {
       
        for( var i = 0; i < error_count; i++ )
            console.log( "Parse error near " + text.substr( error_offsets[i] ) + ", expecting \"" + error_lookaheads[i].join() + "\"" );
    }
    else {
      
      console.log('> ' + JSON.stringify(result)); // print the read stage text back as the print stage
    }
  }

  process.stdout.write("> "); // now loop or wait for user input again
});
*]
