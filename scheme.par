[* // Author: Travis Hoover, thoov7@gmail.com


//
// Alist is the symbol table.
//
// Holds all of the symbols and their values along with primative functions.
//
var alist = { type:'NULL' };
var primfns = [];

//
// Make functions for the alist
//
var makeNumber = function ( number ) {

    return { type:'NUMBER', val:number };
}
var makeNull = function () {
    
    return { type:'NULL' };
}
var makeSymbol = function( symbol ) {
    
    return { type:'SYMBOL', val:symbol };    
}
var makeString = function( string ) {
    
    return { type:'STRING', val:string };
}
var makeCons = function ( car, cdr ) {
    
    return { type:'CONS', car:car, cdr:cdr };
}
var makePrimFunction = function ( number ) {
    return { type:'PRIM', val:number };
}

var makeElement = function (type, value) {
    return { type:type, val:value};
}
var appendAlist = function (type, value) {
    
    alist = makeCons( makeCons(makeSymbol('PI'), makeNumber(3.14)),  alist);
}

//
// load the primative functions into the alist.
//
alist = makeCons( makeCons(makeSymbol('def'), makePrimFunction(1)),  alist);
alist = makeCons( makeCons(makeSymbol('+'), makePrimFunction(2)),  alist);
alist = makeCons( makeCons(makeSymbol('-'), makePrimFunction(3)),  alist);
alist = makeCons( makeCons(makeSymbol('PI'), makeNumber(3.14)),  alist);


//
// Prim function for def
//
// TODO: make sure correct types.
//
primfns[1] = function (sexpr) {
    
    var def = sexpr[0]; // The def keyword is the first token on the stack.

    var variable  = sexpr[1]; // The second token is the variable being defined.


    //
    // The third param is the value for the variable
    // It can either be an atom or a sub list. We eval it to get a value.
    //
    var value = eval(sexpr[2]);
    
    
    //
    // Insert into alist the new variable that was defined.
    //
    if (typeof value === 'number') {
        
        alist = makeCons( makeCons(variable, makeNumber(value)),  alist);   
    }
    else if (typeof value === 'string') {
    
        alist = makeCons( makeCons(variable, makeString(value)),  alist);
    }
    else {
        
        console.log("Feature not added yet.");
    }
    
    return true;
}

//
// Prim function for +
//
primfns[2] = function (sexpr) {

    var plus = sexpr[0]; // The plus sign

    var value = eval(sexpr[1]); // The first element after the + sign goes on the left hand side of the plus sign.


    //
    // Loop through the rest of the elments and add them up.
    //
    for (var i = 2; i < sexpr.length; i++) {
        
        value += eval(sexpr[i]);
    }
    
    return value;
}




//
// Loopup symbols inside of the alist.
//
// @param symbol - The symbol to find inside of the alist.
// @return - { type:'PRIM', val:1 } or { type:'NUMBER', val:23} or false if not found.
//
var lookup = function (symbol) {

    var alistPtr = alist;
        
    while (alistPtr.type !== 'NULL') {
        
        if (alistPtr.car.car.val == symbol.val) {

            // The return value is like { type:'PRIM', val:1 } or { type:'NUMBER', val:23}
            return alistPtr.car.cdr;
        }
        else {
            
            alistPtr = alistPtr.cdr; // "advance the pointer"

            // If null then we are at the end of the alist.
            if (alistPtr.type === 'NULL') { alistPtr = { type:'NULL' }; } 
        }
    }
    
    return false;
}

var listSymbols = function () {
    
    var alistPtr = alist;
    
    while (alistPtr.type !== 'NULL') {
    
        console.log(alistPtr.car.car.val);
                
        alistPtr = alistPtr.cdr; // "advance the pointer"

        // If null then we are at the end of the alist.
        if (alistPtr.type === 'NULL') { alistPtr = { type:'NULL' }; } 
        
    }

}




//
// Evaluation function. Pops off sexpr from a tokenized stack of sexpr.
//
// @param SEXPR - A stack of sexpr expressions to be evaluated.
// @param RETURN - Return the value of an individual token.
//
var eval = function( SEXPR ) {

    var currentSexpr = SEXPR;
    var parentExpression = SEXPR;

    //
    // If the sexpr is a list then we want to eval the array.
    //
    if (SEXPR.type === 'LIST') {
        currentSexpr = SEXPR.val[0];
        parentExpression = SEXPR.val;
    }


    if (currentSexpr.type === 'SYMBOL') {
        
        var lookupValue = lookup( currentSexpr );
        
        if (lookupValue.type === 'PRIM') {
             
            return primfns[lookupValue.val]( parentExpression );
        }
        else if (lookupValue.type !== 'NULL') {
            
            return lookupValue.val;
        }
        else {
            
            // Error invalid symbol not defined.  
            process.exit(1); 
        }
    }
    else if(currentSexpr.type === 'LIST') {
        
        return eval(currentSexpr.val);
    }
    else { // Numbers and strings

        return currentSexpr.val;
    }
}





var tokenized = null;
var createItem = function (identifier, value) { return {type:identifier.toUpperCase, val:value}; };
var create_null = function () { return { type:'NULL' }; }
var create_string = function (x) { return { type:'STRING', val:x }; }
var create_symbol = function (x) { return { type:'SYMBOL', val:x }; }
var create_number = function (x) { return { type:"NUMBER", val:x }; }
var create_list = function (x) { 
    
    if ( isArray(x) ) { return { type:'LIST', val:x }; }
    
    return { type:'LIST', val:[x] }; 
}
var create_dot_list = function (x, y) { 
    
    var array = []; // this holds the "proper" array
    
    //
    // Before the dot
    //
    if ( isArray(x.val) ) {
        for ( var i = 0; i < x.val.length; i++ ) {
            array.push(x.val[i]);
        }
    }
    else { array.push(x); }
    
    //
    // After the dot
    //
    if ( isArray(y.val) ) {
        for ( var i = 0; i < y.val.length; i++ ) {
            array.push(y.val[i]);
        }
    }
    else { array.push(y); }

    return { type:'LIST', val:array };
}
var array_append = function (x, y) { 
    
    if( isArray(x) ) { x.push(y); return x; }
    
    return [x,y];    
}

var isArray = function (x) { return ( x instanceof Array ); }

*]

/~ Tokens Definitions for Scheme Syntax ~/

/~ Tokens to be ignored (e.g. whitespace, comments) ~/
! ' |\t|\r\n|\n|;[^\n]*\n' 
;

/~ Token pattern matching rules ~/
    '[ ]?\)'                                      RPAREN
    '\([ ]?'                                      LPAREN
    '\.'                                          DOT
    '[0-9]+[ ]?|[0-9]+\.[0-9]*|[0-9]*\.[0-9]+'    NUMBER   [* %match = parseFloat( %match ); *]
    '[^\(\)0-9\.\'\`\,\@" ][^\) ]*'               SYMBOL   [* /*symbols cannot begin with digits, parens, quotes, dots, etc.*/ *]
    '\"[^"]*\"'                                   STRING   [* %match = %match.substr( 1, %match.length - 2 ); *]
  ;

##


readonce:   sexpr                                    [* tokenized = %1; *]
            ;

sexpr:      atom                                      
            | list                                   [* %% = %1; *]
            ;

list:       LPAREN RPAREN	                         [* %% = create_null(); *]
	        | LPAREN members RPAREN                  [* %% = create_list(%2) *]
	        | LPAREN members DOT sexpr RPAREN        [* %% = create_dot_list(%2, %4); *]
            ;

members:    members sexpr                            [* %% = array_append(%1, %2); *]
            | sexpr                                  [* %% = %1; *]
            ;

atom:       NUMBER                                   [* %% = create_number(%1); *]
            | SYMBOL                                 [* %% = create_symbol(%1); *]
            | STRING                                 [* %% = create_string(%1); *]
            ;
            


[*
var error_offsets = new Array();
var error_lookaheads = new Array();
var error_count = 0;
var DEBUG = false;

console.log("Welcome to the Scheme REPL by Travis Hoover");

process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdout.write("> ");

process.argv.forEach(function (val, index, array) {
    if( val === '--debug' || val === '-d' ){
        DEBUG = true;
    }
});

process.stdin.on('data', function (text) {

    // ( R )
    
    text = text.trim();
    
    if( text != "" ) {
        
                    
        if (text.toLowerCase() == 'print alist') {
            
            listSymbols();
        }
        else {
        
            // send text to scheme tokenizer ( E )
            if( ( error_count = __NODEJS_parse( text, error_offsets, error_lookaheads ) ) > 0 ) {
           
                for( var i = 0; i < error_count; i++ )
                    console.log( "Parse error near " + text.substr( error_offsets[i] ) + ", expecting \"" + error_lookaheads[i].join() + "\"" );
            }
            else {
          
                if (DEBUG) { 
                    
                    console.log('> Tokenized: ');
                    console.log(JSON.stringify(tokenized)); 
                    console.log('> Eval: ');
                    
                
                }
                console.log(eval(tokenized)); // Print the evaluated expression ( P )
            }
        }
    }
    process.stdout.write("> "); // now loop or wait for user input again ( L )
});
*]
