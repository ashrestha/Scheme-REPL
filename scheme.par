[* // Javascript code used the evaluation part of the REPL

var STANDARD_FUNCTIONS = ["DEFINE", "+", "-", "*", "/"];
var VARIABLES = [];

VARIABLES["TESTING"] = 23;
VARIABLES["FOOBAR"] = 27;


var SYMBOL = "SYMBOL";
var LIST = "LIST";



//
// Go through the list and turn identifiers into values.
// Keep standard function identifiers
//


var standardize = function ( tokenized ) { 

    if ( tokenized.type.toUpperCase() === LIST ) {
        
        var array = [];

                    
        // move down the stack and 'pop' the list off of the stack
        for ( var i = 0; i < tokenized.val.length; i++ ) {
            
            if( (tokenized.val[0].val.toUpperCase() == "DEFINE" && i == 1) ) {
                array.push(tokenized.val[i]); 
            }
            else {
                array.push(standardize( tokenized.val[i] ));
            }
        
        }
                
        return array;
    }
    else if ( tokenized.type.toUpperCase() === SYMBOL ) {
        
        // loop up the symbol in the standard lib or the global var table
        if ( standardLib(tokenized.val.toUpperCase()) ) {
            
            return standardLib(tokenized.val.toUpperCase());
            
        } else if ( variableLookup(tokenized.val.toUpperCase().trim()) ) {
            
            return variableLookup(tokenized.val.toUpperCase());
        }
        else {
            
            console.log("Unidentified identifier: " + tokenized.val);
            process.exit(1);
        }
    }
    else {
        
        console.log("The token we are looking at is either a string or a number: " + tokenized.val);
        return tokenized.val;
    } 
}




//
// At this point every list should start with a symbol followed by numbers or strings. 
//



var standardLib = function ( token ) {
        
    if( STANDARD_FUNCTIONS.indexOf( token ) !== -1 ) {
        
        return token;
    }
    
    return false; 
}

var variableLookup = function ( token ) {
        
    if ( VARIABLES[token] !== null ) {
        
        return VARIABLES[token];
    }
    
    return false;
}


var tokenized = null;

var create_null = function () { return { type:'NULL' }; }
var create_string = function (x) { return { type:'STRING', val:x }; }
var create_symbol = function (x) { return { type:SYMBOL, val:x }; }
var create_number = function (x) { return { type:"NUMBER", val:x }; }
var create_list = function (x) { 
    
    if ( isArray(x) ) { return { type:'LIST', val:x }; }
    
    return { type:'LIST', val:[x] }; 
}
var create_dot_list = function (x, y) { 
    
    var array = []; // this holds the "proper" array
    
    //
    // Before the dot
    //
    if ( isArray(x.val) ) {
        for ( var i = 0; i < x.val.length; i++ ) {
            array.push(x.val[i]);
        }
    }
    else { array.push(x); }
    
    //
    // After the dot
    //
    if ( isArray(y.val) ) {
        for ( var i = 0; i < y.val.length; i++ ) {
            array.push(y.val[i]);
        }
    }
    else { array.push(y); }

    return { type:'LIST', val:array };
}
var array_append = function (x, y) { 
    
    if( isArray(x) ) { x.push(y); return x; }
    
    return [x,y];    
}

var isArray = function (x) { return ( x instanceof Array ); }

*]

/~ Tokens Definitions for Scheme Syntax ~/

/~ Tokens to be ignored (e.g. whitespace, comments) ~/
! ' |\t|\r\n|\n|;[^\n]*\n' 
;

/~ Token pattern matching rules ~/
    '[ ]?\)'    RPAREN
    '\([ ]?'    LPAREN
    '\.'        DOT
    '[0-9]+[ ]?|[0-9]+\.[0-9]*|[0-9]*\.[0-9]+'    NUMBER   [* %match = parseFloat( %match ); *]
    '[^\(\)0-9\.\'\`\,\@" ][^\) ]*'               SYMBOL   /~ symbols cannot begin with digits, parens, quotes, dots, etc. ~/
    '\"[^"]*\"'                                   STRING   [* %match = %match.substr( 1, %match.length - 2 ); *]
  ;

##


readonce:   sexpr                                    [* tokenized = %1; *]
            ;

sexpr:      atom                                      
            | list                                   [* %% = %1; *]
            ;

list:       LPAREN RPAREN	                         [* %% = create_null(); *]
	        | LPAREN members RPAREN                  [* %% = create_list(%2) *]
	        | LPAREN members DOT sexpr RPAREN        [* %% = create_dot_list(%2, %4); *]
            ;

members:    members sexpr                            [* %% = array_append(%1, %2); *]
            | sexpr                                  [* %% = %1; *]
            ;

atom:       NUMBER                                   [* %% = create_number(%1); *]
            | SYMBOL                                 [* %% = create_symbol(%1); *]
            | STRING                                 [* %% = create_string(%1); *]
            ;
            


[*
var error_offsets = new Array();
var error_lookaheads = new Array();
var error_count = 0;
var DEBUG = false;

console.log("Welcome to the Scheme REPL by Travis Hoover");

process.stdin.resume();
process.stdin.setEncoding('utf8');
process.stdout.write("> ");

process.argv.forEach(function (val, index, array) {
    if( val === '--debug' || val === '-d' ){
        DEBUG = true;
    }
});

process.stdin.on('data', function (text) {

    // ( R )
    
    if( text.trim() != "" ) {
    
        // send text to scheme tokenizer ( E )
        if( ( error_count = __NODEJS_parse( text.trim(), error_offsets, error_lookaheads ) ) > 0 ) {
       
            for( var i = 0; i < error_count; i++ )
                console.log( "Parse error near " + text.substr( error_offsets[i] ) + ", expecting \"" + error_lookaheads[i].join() + "\"" );
        }
        else {
      
            if (DEBUG) { 
                
                console.log('> Tokenized: ');
                console.log('> ' + JSON.stringify(tokenized)); 
                
                console.log('> ');
                console.log('> Standardized: ');
                console.log(standardize(tokenized));
                //console.log(tokenized);
            
            } // print the internal json structure
            process.stdout.write(text); // print the read stage text back as the print stage ( P )
        }
    }
    process.stdout.write("> "); // now loop or wait for user input again ( L )
});
*]
